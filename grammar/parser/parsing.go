// Code generated by "grammar -i=g.txt";

package parser

import (
	"io"

	"github.com/PlayerR9/SlParser"
	"github.com/PlayerR9/SlParser/grammar"
	"github.com/PlayerR9/SlParser/parser"
	"github.com/PlayerR9/go-evals/result"
	"github.com/PlayerR9/mygo-lib/trees"
)

const (
	EtEOF       string = "EtEOF"
	TtColon     string = "TtColon"
	TtPipe      string = "TtPipe"
	TtRhs       string = "TtRhs"
	TtSemicolon string = "TtSemicolon"
	NtLhs       string = "NtLhs"
	NtOrExpr    string = "NtOrExpr"
	NtRhss      string = "NtRhss"
	NtRule      string = "NtRule"
	NtSource    string = "NtSource"
	NtSource1   string = "NtSource1"
)

var (
	WriteTokenTree func(w io.Writer, tk *grammar.Token) (int, error)
	Parser         parser.Parser
)

func init() {
	WriteTokenTree = trees.MakeWriteTree[*grammar.Token]()
	var builder parser.Builder

	_ = builder.AddRule(NtSource, NtSource1, EtEOF)
	_ = builder.AddRule(NtSource1, NtRule)
	_ = builder.AddRule(NtSource1, NtRule, NtSource1)
	_ = builder.AddRule(NtRule, NtLhs, TtColon, NtRhss, TtSemicolon)
	_ = builder.AddRule(NtRhss, NtOrExpr)
	_ = builder.AddRule(NtRhss, NtOrExpr, NtRhss)
	_ = builder.AddRule(NtOrExpr, TtRhs)
	_ = builder.AddRule(NtOrExpr, TtRhs, TtPipe, NtOrExpr)

	Parser = parser.NewParser(builder.Build())
}

var Evaluate result.ApplyOnValidsFn[SlParser.Result[*Node]]

func init() {
	var err error

	Evaluate, err = SlParser.MakeEvaluate(Lexer, Parser, Ast)
	if err != nil {
		panic(err)
	}
}

// Result holds all the information regarding the parsing process. This is read-only.
type Result struct {
	// inner holds the inner result.
	inner *SlParser.Result[*Node]
}

// Data returns the data of the result.
//
// Returns:
//   - []byte: The data of the result.
//   - bool: True if the data is set, false otherwise.
func (r Result) Data() ([]byte, bool) {
	data, err := r.inner.Data()
	return data, err == nil
}

// Tokens returns the tokens of the result.
//
// Returns:
//   - []*grammar.Token: The tokens of the result.
//   - bool: True if the tokens are set, false otherwise.
func (r Result) Tokens() ([]*grammar.Token, bool) {
	tokens, err := r.inner.Tokens()
	return tokens, err == nil
}

// ParseTree returns the parse tree of the result.
//
// Returns:
//   - *parser.Result: The parse tree of the result.
//   - bool: True if the parse tree is set, false otherwise.
func (r Result) ParseTree() (*parser.Result, bool) {
	pr, err := r.inner.ParseTree()
	return pr, err == nil
}

// Node returns the node of the result.
//
// Returns:
//   - *Node: The node of the result.
//   - bool: True if the node is set, false otherwise.
func (r Result) Node() (*Node, bool) {
	n, err := r.inner.Node()
	return n, err == nil
}

// LexerErr returns the lexer error of the result.
//
// Returns:
//   - error: The lexer error of the result.
//   - bool: True if the lexer error is set, false otherwise.
func (r Result) LexerErr() (error, bool) {
	err1, err2 := r.inner.LexerErr()
	return err1, err2 == nil
}

// Err returns the error of the result.
//
// Returns:
//   - error: The error of the result. Nil if no error is set.
func (r Result) Err() error {
	return r.Err()
}

// Parse parses the given data according to the grammar.
//
// Parameters:
//   - data: The data to parse.
//
// Returns:
//   - []Result: A slice containing the result of the parsing process.
//   - error: An error if the evaluation failed.
func Parse(data []byte) ([]Result, error) {
	result := SlParser.NewResult[*Node](data)

	results, err := Evaluate([]SlParser.Result[*Node]{result})

	slice := make([]Result, 0, len(results))

	for _, r := range results {
		rsl := Result{
			inner: &r,
		}
		slice = append(slice, rsl)
	}

	return slice, err
}
